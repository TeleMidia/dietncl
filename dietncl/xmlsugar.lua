--[[ dietncl.xmlsugar -- LuaXML sugar.
     Copyright (C) 2013-2017 PUC-Rio/Laboratorio TeleMidia

This file is part of DietNCL.

DietNCL is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your
option) any later version.

DietNCL is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with DietNCL.  If not, see <http://www.gnu.org/licenses/>.  ]]--

local bit = bit32.extract
local getmetatable = getmetatable
local setmetatable = setmetatable
local tostring = tostring
local assert = assert
local ipairs = ipairs
local pairs = pairs
local next = next
local pcall = pcall
local table = table
local type = type
local io = io
local print = print

local xml = require'dietncl.xmllib'
_ENV = nil

-- Checks whether E is a LuaXML element.
local function checkxml (e)
   local t = getmetatable (e)
   assert (t and t.__index == xml)
   return e
end

-- Sets PARENT to be the parent element of E.
local function setparent (e, parent)
   e[0].parent = parent
end


--- Methods
-- @section Methods
---

-- Sets or returns tag of a LuaXML object.
function xml.tag (var, tag)
   if tag == nil then
      return var[0].tag
   end

   var[0].tag = assert (tostring (tag))
end

-- Creates a new LuaXML object either by setting the metatable of an
-- existing Lua table or by setting its tag.
function xml.new (arg)
   if type (arg) == "table" then
      setmetatable(arg, {__index=xml, __tostring=xml.str})
      return arg
   end

   local var = {[0] = {}}
   setmetatable (var, {__index=xml, __tostring=xml.str})

   if type (arg) == "string" then
      var[0].tag = arg
   end

   return var
end

-- Appends a new subordinate LuaXML object to an existing one,
-- optionally setting its tag.
function xml.append (var, tag)
   local newVar = xml.new (tag)
   var[#var+1] = newVar
   return newVar
end

-- Converts any Lua var into a XML string
function xml.str (var, level)
   local level = level or 0
   local s = ''
   local indent = '\t'
   local child = ''

   s = indent:rep (level) .. '<' .. var[0].tag

   for k, v in pairs (var) do
      if type (k) == "string" then
         s = s .. ' ' .. k .. '="' .. v .. '"'
      end
   end

   for _, v in ipairs (var) do
      child = child .. xml.str (v, level +1)
   end

   if child == '' then
      s = s .. '/>\n'
   else
      s = s .. '>\n' .. child .. indent:rep (level) .. '</' .. var[0].tag .. '>\n'
   end
   return s
end

-- Saves a Lua var as XML file
function xml.save(var,filename)
   local file = io.open (assert (tostring (filename)), "w")
   file:write ("<?xml version=\"1.0\"?>\n<!-- file \"", filename,
              "\", generated by LuaXML -->\n\n")
   file:write (xml.str (var))
   io.close (file)
end

-- Recursively parses a Lua table for a substatement fitting to the provided
-- tag and attribute.
function xml.find (var, tag, key, value)
   if type (var) ~= "table" then
      return nil
   end

   -- compare this table:
   if var[0].tag == tag and (value == nil or var[key] == value) then
      setmetatable (var, {__index=xml, __tostring=xml.str})
      return var
   end
   if tag == nil and var[key] == value then
      setmetatable (var, {__index=xml, __tostring=xml.str})
      return var
   end

   -- recursively parse subtags:
   for _, v in ipairs (var) do
      local ret = xml.find (v, tag, key, value)
      if ret ~= nil then
         return ret
      end
   end
end

---
-- Parses XML string.
-- @param s XML string.
-- @return[1] XML tree (root element), if successful.
-- @return[2] `nil` plus error message, otherwise.
---
function xml:eval (s)
   local s = s or self
   local status, e = pcall (xml.parse_string, s)
   if status == false or e == nil then
      return nil, e
   end
   return e
end

---
-- Parses XML file.
-- @string path path to XML file.
-- @return[1] XML tree (root element), if successful.
-- @return[2] `nil` plus error message, otherwise.
---
function xml:load (path)
   local path = path or self
   local status, e = pcall (xml.parse_file, path)
   if status == false or e == nil then
      return nil, e
   end
   return e
end

---
-- Gets element's parent.
-- @return parent element.
---
function xml:parent()
   checkxml (self)
   return self[0].parent
end

---
-- Searches for element's child.  This function assumes that *child* is in
-- element's child list.
-- @param child the searched child or its position in child list.
-- @return *child* and its position in child list.
---
function xml:findchild (child)
   local pos
   if type (child) == 'number' then
      pos = child
      child = assert (self[pos])
   else
      checkxml (child)
      assert (child[0].parent == self)
      for i=1,#self do
         if child == self[i] then
            pos = i
         end
      end
      assert (pos)
   end
   return child, pos
end

---
-- Inserts child element.
-- @param[opt] pos position in child list or `nil` (last+1).
-- @param child child to be inserted.
-- @return the position where *child* was inserted.
---
function xml:insert (pos, child)
   checkxml (self)
   if child == nil then
      child = pos
      pos = #self + 1
   end
   assert (pos >= 1 and pos <= #self + 1)
   assert (child[0].parent == nil)
   setparent (child, self)
   table.insert (self, pos, child)
   return pos
end

---
-- Removes child element.
-- @param child child to be removed or its position in child list.
-- @return *child* and its position in child list.
---
function xml:remove (child)
   checkxml (self)
   local child, pos = self:findchild (child)
   table.remove (self, pos)
   setparent (child, nil)
   return child, pos
end

---
-- Replaces child element.
-- @param old child to be replaced or its position in child list.
-- @param new the replacement element.
-- @return *old* and its position in child list.
---
function xml:replace (old, new)
   checkxml (self)
   checkxml (new)
   assert (new[0].parent == nil)
   local old, pos = self:findchild (old)
   self[pos] = new
   setparent (new, self)
   setparent (old, nil)
   return old, pos
end

---
-- Gets element user data.
-- @param key key the data was attached to.
-- @return the data with the given key if any.
---
function xml:getuserdata (key)
   checkxml (self)
   if self[0].userdata == nil then
      return nil
   end
   return self[0].userdata[key]
end

---
-- Sets element user data.
-- @param key key to attach the data to.
-- @param data data to attach to the element.
---
function xml:setuserdata (key, data)
   checkxml (self)
   if self[0].userdata == nil then
      self[0].userdata = {}
   end
   self[0].userdata[key] = data
end

---
-- Gets child list iterator.
-- @return iterator function for element's child list.
---
function xml:children ()
   checkxml (self)
   local t = {}
   for i=1,#self do
      t[i] = self[i]
   end
   local i = 1
   return function ()
      if i <= #t then
         local x = t[i]
         i = i + 1
         return x
      end
      return nil
   end
end

---
-- Gets attribute table iterator.
-- @return iterator function for element's attribute table.
---
function xml:attributes ()
   checkxml (self)
   local i = nil
   return function ()
      local k, v = next (self, i)
      while type (k) == 'number' do
         k, v = next (self, k)
      end
      i = k
      return k, v
   end
end

---
-- Tests whether the element tree is equal to another tree.
-- @function xml:equal
-- @param other XML tree (root element).
-- @return[1] `true`, if successful.
-- @return[2] `false`, otherwise.
---
local function equal_attributes (e1, e2)
   for k,_ in e1:attributes () do
      if e1[k] ~= e2[k] then
         return false
      end
   end
   return true
end

function xml:equal (other)
   checkxml (self)
   checkxml (other)
   if (self:tag () ~= other:tag ())
      or (not equal_attributes (self, other))
      or (not equal_attributes (other, self))
      or (#self ~= #other) then
      return false
   end
   for i=1,#self do
      if (not self[i]:equal (other[i]))
         or (not other[i]:equal (self[i])) then
         return false
      end
   end
   return true
end

---
-- Clones element tree.
-- @return a copy of element tree (root element).
---
function xml:clone ()
   checkxml (self)
   local t = xml.new (self:tag ())
   for k,v in self:attributes () do
      t[k] = v
   end
   for i=1,#self do
      t[i] = (self[i]:clone ())
      setparent (t[i], t)
   end
   return t
end

---
-- Traverses element tree.
-- @param action a function to be applied to each traversed element.
---
function xml:walk (action)
   checkxml (self)
   action (self)
   for i=1,#self do
      self[i]:walk (action)
   end
end

---
-- Searches for all elements that match the given search criterion in the
-- element's tree.
-- @function xml:match
-- @param[opt] tag tag name or `nil` (any).
-- @param[opt] attr attribute name or `nil` (any).
-- @param[opt] value attribute value or `nil` (any).
-- @param[opt=0] regexp integer between 0-7 that determines whether *tag*,
-- *attr*, or *value* are to be interpreted as regular expressions: if the
-- third bit of *regexp* is set, treat *tag* as regexp; if its second bit is
-- set, treat *attr* as regexp; if its first bit is set, treat *value* as
-- regexp.
-- @return the matched elements.
---
local function eq (s, pattern, regexp)
   if regexp then
      return s:match (pattern) ~= nil
   else
      return s == pattern
   end
end

local function domatch0 (e, tag, attr, value,
                         cmptag, cmpattr, cmpval, result)

   if tag and not cmptag (e:tag (), tag) then
      return                    -- fail
   end

   if not attr then
      cmpattr = function (...) return true end
   end

   if not value then
      cmpval = function (...) return true end
   end

   local list = {}
   for k,_ in e:attributes () do
      if cmpattr (k, attr) then
         list[#list+1] = k
      end
   end

   if attr and #list == 0 then
      return                    -- fail
   end

   if value then
      for _,attr in ipairs (list) do
         assert (e[attr])
         if cmpval (e[attr], value) then
            goto success
         end
      end
      return                    -- fail
   end

   ::success::
   table.insert (result, e)
end

local function domatch (e, tag, attr, value, regexp)
   local result = {}            -- list of matches
   local match = function (e)
      local re = regexp or 0
      domatch0 (e, tag, attr, value,
                function (x,y) return eq (x, y, bit (re, 2) ~= 0) end,
                function (x,y) return eq (x, y, bit (re, 1) ~= 0) end,
                function (x,y) return eq (x, y, bit (re, 0) ~= 0) end,
                result)
   end
   xml.walk (e, match)
   return result
end

function xml:match (...)
  return table.unpack (domatch (self, ...))
end

---
-- Gets match iterator.
-- @param[opt] tag tag name or `nil` (any).
-- @param[opt] attr attribute name or `nil` (any).
-- @param[opt] value a value string or `nil` (any).
-- @param[opt=0] regexp see `xml:match`.
-- @return an iterator function for the given search criterion.
---
function xml:gmatch (...)
   local t = domatch (self, ...)
   local i = 1
   return function ()
      if i <= #t then
         local x = t[i]
         i = i + 1
         return x
      end
      return nil
   end
end

return xml
